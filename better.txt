1、usecase层代码冗余优化:
    最终调用不同业务层得代码入口在router层，路由调用的方法有一个传参得返回值为func(*Context)类型得函数
    。ok，现在要把冗余的接收请求参数转化并处理返回请求的部分（每个usecase层都需要处理三遍）分离出来，首先需要的就是定义一个自定义
    函数，函数的返回值当然为func(*Context)。ok，那么接下来就要考虑怎么整合了，之前每次接收到请求后，都需要调用context.BindJSON()
    方法将请求转为对应自定义协议类型的结构体，既然要整合那么就要用到interface{}作为该函数的入参用于定义该函数每次处理时候的请求类型，然
    后就可以将每次的JSON请求转为对应的结构体。拿到对应协议的结构体后，就需要通过usecase层来调用repo层的方法进行数据处理，为了方便处理，可
    以将usecase层的方法handler定义为一个type，然后将方法作为一个入参传入整合的函数中就可以在函数中统一处理usecase的各种方法。将前面的request结构体传
    到为interface{}类型入参的handler中，通过断言的形式实现具体业务场景中的转化即可。


2、单例模式优化:
    各个层之间需要用到别的层的方法就需要对应结构体实例，但是频繁的new实例太损耗空间，不符合单例。可以在各层的结构体中加入该层需要调用的结构体变量
    然后在一个包下通过init函数实现统一的初始化，一层一层的依赖注入进去，形成单例模式。结构体想调用上一层的方法只需要取出结构体中的上一层结构体类型变量
    即可调用，不需要new一个新的实例

3、algo循环判断链路可达优化:
    现在的办法:查出点线资源后，循环取出点线资源后查出资源下一个可达的资源组，循环判断自己是否在上一个资源的可达组中
    优化方法:循环取点线资源时通过下标的方法取出当前资源和下一个资源的id和type，直接查询当前资源是否可达下一个资源，可以减少一次循环嵌套